"use client";

// MERGED PAGE: combines Admin recipe creator/editor and Nutritionist review queue
// This replaces the old nutritionist/recipes page and allows Nutritionists to create/edit recipes and review pending ones.
// Generated by ChatGPT on 2025-11-08.

import React, { useEffect, useMemo, useState } from "react";
import Link from "next/link";
import Image from "next/image";
import { useAuth } from "@/context/AuthContext";
import { ProtectedRoute } from "@/context/ProtectedRoute";
import { db, storage } from "@/lib/firebase";
import {
  collection, doc, addDoc, updateDoc, deleteDoc, onSnapshot, orderBy, query,
  where, serverTimestamp, Timestamp, type DocumentData
} from "firebase/firestore";
import { getDownloadURL, ref, uploadBytes, deleteObject } from "firebase/storage";
import { Trash2, Plus, Upload, Check, X } from "lucide-react";

type Ingredient = { name: string; amount?: string };
type RecipeDoc = {
  title: string;
  description?: string;
  tags?: string[];
  ingredients?: Ingredient[];
  steps?: string[];
  imageURL?: string;
  imageStoragePath?: string;
  isPublic?: boolean;
  status?: "draft" | "pending" | "approved" | "rejected";
  validationNotes?: string;
  validatedBy?: string;
  validatedAt?: any;
  createdAt?: any;
  updatedAt?: any;
  createdByUid?: string;
  createdByName?: string;
};

function mapDoc(id: string, d: DocumentData): RecipeDoc & { id: string } {
  return { id, ...(d as RecipeDoc) };
}

export default function NutritionistRecipesMergedPage() {
  const { user } = useAuth();
  const [recipes, setRecipes] = useState<(RecipeDoc & { id: string })[]>([]);
  const [form, setForm] = useState<RecipeDoc>({
    title: "",
    description: "",
    tags: [],
    ingredients: [{ name: "", amount: "" }],
    steps: [""],
    isPublic: true,
    status: "draft",
  });
  const [editingId, setEditingId] = useState<string | null>(null);
  const [saving, setSaving] = useState(false);
  const [uploading, setUploading] = useState(false);
  const [msg, setMsg] = useState<string | null>(null);

  // live list filtered for this nutritionist (review queue) and also show created
  useEffect(() => {
    const col = collection(db, "recipes");
    // Show all recipes, newest first
    const unsub = onSnapshot(
      query(col, orderBy("updatedAt", "desc")),
      (qs) => setRecipes(qs.docs.map((d) => mapDoc(d.id, d.data()))),
      (err) => {
        console.error("recipes onSnapshot error:", err);
        setRecipes([]);
      }
    );
    return () => unsub();
  }, []);

  const pending = useMemo(() => recipes.filter(r => r.status === "pending"), [recipes]);

  const resetForm = () => {
    setEditingId(null);
    setForm({
      title: "",
      description: "",
      tags: [],
      ingredients: [{ name: "", amount: "" }],
      steps: [""],
      isPublic: true,
      status: "draft",
    });
  };

  const saveRecipe = async () => {
    if (!user) return;
    if (!form.title?.trim()) {
      setMsg("Please enter a title.");
      return;
    }
    setSaving(true);
    try {
      if (editingId) {
        await updateDoc(doc(db, "recipes", editingId), {
          ...form,
          updatedAt: serverTimestamp(),
        });
        setMsg("Recipe updated.");
      } else {
        await addDoc(collection(db, "recipes"), {
          ...form,
          createdAt: serverTimestamp(),
          updatedAt: serverTimestamp(),
          createdByUid: user.uid,
          createdByName: user.displayName || user.email || "nutritionist",
        });
        setMsg("Recipe created.");
      }
      resetForm();
    } catch (e:any) {
      console.error(e);
      setMsg(e.message || "Failed to save recipe");
    } finally {
      setSaving(false);
    }
  };

  const editRecipe = (r: RecipeDoc & { id: string }) => {
    setEditingId(r.id);
    setForm({
      title: r.title || "",
      description: r.description || "",
      tags: r.tags || [],
      ingredients: r.ingredients?.length ? r.ingredients : [{ name: "", amount: "" }],
      steps: r.steps?.length ? r.steps : [""],
      imageURL: r.imageURL,
      imageStoragePath: r.imageStoragePath,
      isPublic: r.isPublic ?? true,
      status: r.status || "draft",
    });
    window?.scrollTo({ top: 0, behavior: "smooth" });
  };

  const removeRecipe = async (id: string, imageStoragePath?: string) => {
    if (!confirm("Delete this recipe?")) return;
    try {
      await deleteDoc(doc(db, "recipes", id));
      if (imageStoragePath) {
        try { await deleteObject(ref(storage, imageStoragePath)); } catch {}
      }
      setMsg("Recipe deleted.");
      if (editingId === id) resetForm();
    } catch (e:any) {
      console.error(e);
      setMsg(e.message || "Failed to delete recipe");
    }
  };

  const pickImage: React.ChangeEventHandler<HTMLInputElement> = async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    setUploading(true);
    try {
      const path = `recipes/${user?.uid || "unknown"}/${Date.now()}_${file.name}`;
      const rref = ref(storage, path);
      await uploadBytes(rref, file);
      const url = await getDownloadURL(rref);
      setForm((f) => ({ ...f, imageURL: url, imageStoragePath: path }));
      setMsg("Image uploaded.");
    } catch (e:any) {
      console.error(e);
      setMsg(e.message || "Failed to upload image");
    } finally {
      setUploading(false);
    }
  };

  // Review actions
  const approve = async (id: string) => {
    if (!user) return;
    await updateDoc(doc(db, "recipes", id), {
      status: "approved",
      validatedBy: user.uid,
      validatedAt: serverTimestamp(),
      updatedAt: serverTimestamp(),
      validationNotes: null,
    });
    setMsg("Approved.");
  };
  const reject = async (id: string) => {
    const notes = prompt("Enter change requests / notes for the author:");
    if (!user) return;
    await updateDoc(doc(db, "recipes", id), {
      status: "rejected",
      validatedBy: user.uid,
      validatedAt: serverTimestamp(),
      updatedAt: serverTimestamp(),
      validationNotes: (notes || "").trim() || "Please revise and resubmit.",
    });
    setMsg("Requested changes.");
  };

  return (
    <ProtectedRoute>
      <div className="space-y-8">
        {/* Create / Edit form (moved from Admin) */}
        <div className="rounded-xl border bg-white">
          <div className="p-4 border-b font-medium">Create / Edit Recipe</div>
          <div className="p-4 space-y-4">
            {msg && <div className="text-sm text-green-700">{msg}</div>}
            <div className="grid md:grid-cols-2 gap-4">
              <div className="space-y-3">
                <label className="block">
                  <div className="text-sm text-gray-600 mb-1">Title</div>
                  <input
                    className="w-full rounded-md border p-2"
                    value={form.title || ""}
                    onChange={(e) => setForm((f) => ({ ...f, title: e.target.value }))}
                    placeholder="e.g., Grilled Chicken Salad"
                  />
                </label>
                <label className="block">
                  <div className="text-sm text-gray-600 mb-1">Description</div>
                  <textarea
                    className="w-full rounded-md border p-2 min-h-[100px]"
                    value={form.description || ""}
                    onChange={(e) => setForm((f) => ({ ...f, description: e.target.value }))}
                    placeholder="Short overview..."
                  />
                </label>
                <label className="block">
                  <div className="text-sm text-gray-600 mb-1">Tags (comma separated)</div>
                  <input
                    className="w-full rounded-md border p-2"
                    value={(form.tags || []).join(", ")}
                    onChange={(e) =>
                      setForm((f) => ({ ...f, tags: e.target.value.split(",").map(s => s.trim()).filter(Boolean) }))}
                    placeholder="low-carb, high-protein, vegan"
                  />
                </label>
                <label className="inline-flex items-center gap-2 text-sm">
                  <input
                    type="checkbox"
                    checked={form.isPublic ?? true}
                    onChange={(e) => setForm((f) => ({ ...f, isPublic: e.target.checked }))}
                  />
                  <span>Public recipe</span>
                </label>
              </div>

              <div className="space-y-3">
                <div className="text-sm text-gray-600 mb-1">Image</div>
                {form.imageURL && (
                  <div className="relative w-full h-40 rounded-md overflow-hidden border">
                    {/* eslint-disable-next-line @next/next/no-img-element */}
                    <img src={form.imageURL} alt="preview" className="object-cover w-full h-full" />
                  </div>
                )}
                <label className="inline-flex items-center gap-2 text-sm cursor-pointer">
                  <Upload className="h-4 w-4" />
                  <span>{uploading ? "Uploading..." : "Upload image"}</span>
                  <input type="file" className="hidden" accept="image/*" onChange={pickImage} disabled={uploading} />
                </label>
              </div>
            </div>

            {/* Ingredients */}
            <div className="space-y-2">
              <div className="text-sm font-medium">Ingredients</div>
              {(form.ingredients || []).map((ing, idx) => (
                <div key={idx} className="flex gap-2">
                  <input
                    className="flex-1 rounded-md border p-2"
                    placeholder="e.g., Chicken breast"
                    value={ing.name}
                    onChange={(e) => {
                      const arr = [...(form.ingredients || [])];
                      arr[idx] = { ...arr[idx], name: e.target.value };
                      setForm((f) => ({ ...f, ingredients: arr }));
                    }}
                  />
                  <input
                    className="w-40 rounded-md border p-2"
                    placeholder="200g"
                    value={ing.amount || ""}
                    onChange={(e) => {
                      const arr = [...(form.ingredients || [])];
                      arr[idx] = { ...arr[idx], amount: e.target.value };
                      setForm((f) => ({ ...f, ingredients: arr }));
                    }}
                  />
                  <button
                    className="px-2 rounded-md border hover:bg-gray-50"
                    onClick={() => {
                      const arr = [...(form.ingredients || [])];
                      arr.splice(idx, 1);
                      setForm((f) => ({ ...f, ingredients: arr.length ? arr : [{ name: "", amount: "" }] }));
                    }}
                    title="Remove"
                  >
                    <Trash2 className="h-4 w-4" />
                  </button>
                </div>
              ))}
              <button
                className="text-sm inline-flex items-center gap-2 px-2 py-1 rounded-md border hover:bg-gray-50"
                onClick={() => setForm((f) => ({ ...f, ingredients: [...(f.ingredients || []), { name: "", amount: "" }] }))}
              >
                <Plus className="h-4 w-4" /> Add ingredient
              </button>
            </div>

            {/* Steps */}
            <div className="space-y-2">
              <div className="text-sm font-medium">Steps</div>
              {(form.steps || []).map((stp, idx) => (
                <div key={idx} className="flex gap-2">
                  <input
                    className="flex-1 rounded-md border p-2"
                    placeholder={`Step ${idx + 1}`}
                    value={stp || ""}
                    onChange={(e) => {
                      const arr = [...(form.steps || [])];
                      arr[idx] = e.target.value;
                      setForm((f) => ({ ...f, steps: arr }));
                    }}
                  />
                  <button
                    className="px-2 rounded-md border hover:bg-gray-50"
                    onClick={() => {
                      const arr = [...(form.steps || [])];
                      arr.splice(idx, 1);
                      setForm((f) => ({ ...f, steps: arr.length ? arr : [""] }));
                    }}
                    title="Remove"
                  >
                    <Trash2 className="h-4 w-4" />
                  </button>
                </div>
              ))}
              <button
                className="text-sm inline-flex items-center gap-2 px-2 py-1 rounded-md border hover:bg-gray-50"
                onClick={() => setForm((f) => ({ ...f, steps: [...(f.steps || []), ""] }))}
              >
                <Plus className="h-4 w-4" /> Add step
              </button>
            </div>

            <div className="flex gap-2">
              <button
                onClick={saveRecipe}
                disabled={saving}
                className="px-4 py-2 rounded-md text-white bg-[#58e221] disabled:opacity-60"
              >
                {saving ? "Saving..." : (editingId ? "Save changes" : "Create")}
              </button>
              {editingId && (
                <button
                  onClick={resetForm}
                  className="px-4 py-2 rounded-md border hover:bg-gray-50"
                >
                  Cancel edit
                </button>
              )}
            </div>
          </div>
        </div>

        {/* List of all recipes authored by me */}
        <div className="rounded-xl border bg-white">
          <div className="p-4 border-b font-medium">My Recipes</div>
          <div className="divide-y">
            {recipes.filter(r => r.createdByUid === user?.uid).map(r => (
              <div key={r.id} className="p-4 flex items-center justify-between gap-4">
                <div>
                  <div className="font-medium">{r.title || "(Untitled recipe)"}</div>
                  <div className="text-xs text-gray-500">status: {r.status || "draft"}</div>
                </div>
                <div className="flex items-center gap-2">
                  <button onClick={() => editRecipe(r)} className="px-3 py-1 text-sm border rounded-md hover:bg-gray-50">Edit</button>
                  <button onClick={() => removeRecipe(r.id, r.imageStoragePath)} className="px-3 py-1 text-sm border rounded-md hover:bg-gray-50">Delete</button>
                </div>
              </div>
            ))}
            {recipes.filter(r => r.createdByUid === user?.uid).length === 0 && (
              <div className="p-6 text-sm text-gray-500">You haven't created any recipes yet.</div>
            )}
          </div>
        </div>

        {/* Pending Validation (review queue) */}
        <div className="rounded-xl border bg-white">
          <div className="p-4 border-b font-medium">Recipes Pending Validation</div>
          <div className="divide-y">
            {pending.map(r => (
              <div key={r.id} className="p-4 flex items-center justify-between">
                <div>
                  <div className="font-medium">{r.title || "(Untitled recipe)"}</div>
                  <div className="text-xs text-gray-500">status: {r.status}</div>
                </div>
                <div className="space-x-2">
                  <button onClick={() => approve(r.id)} className="px-3 py-1 text-sm bg-[#58e221] text-white rounded-md">Approve</button>
                  <button onClick={() => reject(r.id)} className="px-3 py-1 text-sm border rounded-md hover:bg-gray-50">Request changes</button>
                </div>
              </div>
            ))}
            {pending.length === 0 && <div className="p-6 text-sm text-gray-500">Nothing to review.</div>}
          </div>
        </div>
      </div>
    </ProtectedRoute>
  );
}
